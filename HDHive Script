/*
HDHive è‡ªåŠ¨ç­¾åˆ° (ç¨³å®šä¿®å¤ç‰ˆ)
Update: 2026-01-16
Author: ming
Fix: æ¢å›žé€šç”¨ Env æ¨¡å—ï¼Œè§£å†³ "Script Error" å’Œ "read undefined" é—®é¢˜
*/

const $ = new Env("HDHive");

// --- å˜é‡å®šä¹‰ ---
const KEY_COOKIE = 'hdhive_cookie_v12';
const KEY_REFERER = 'hdhive_referer_v12';
const KEY_UA = 'hdhive_ua_v12';
const KEY_USER_ID = 'hdhive_uid_v1';
const DOMAIN = 'hdhive.com';

// æŽ¥å£åœ°å€
const API_CHECKIN = `https://${DOMAIN}/api/customer/user/checkin`;
const API_LOGS = `https://${DOMAIN}/go-api/customer/points-logs?page=1&page_size=10`;

// --- ä¸»ç¨‹åºå…¥å£ ---
(async () => {
  if (typeof $request !== "undefined") {
    await captureCookie();
  } else {
    await main();
  }
})()
  .catch((e) => $.logErr(e))
  .finally(() => $.done());

// --- æ ¸å¿ƒé€»è¾‘ ---
async function main() {
  const cookie = $.getdata(KEY_COOKIE);
  if (!cookie) {
    $.msg($.name, "âŒ æ— æ³•æ‰§è¡Œ", `æœªæ‰¾åˆ° Cookieï¼Œè¯·å…ˆè®¿é—® ${DOMAIN} ç™»å½•`);
    return;
  }

  // 1. æ‰§è¡Œç­¾åˆ°
  const checkInResult = await doCheckIn(cookie);
  
  // 2. å°è¯•æ‹‰å–æ—¥å¿—ï¼ˆå»¶è¿Ÿ 2 ç§’ï¼‰
  if (checkInResult.success || checkInResult.isRepeated) {
     await new Promise(r => setTimeout(r, 2000));
  }
  const serverLogs = await fetchPointsLog(cookie);

  // 3. æž„å»ºæ–‡æ¡ˆ
  const finalContent = buildFinalContent(checkInResult, serverLogs);
  
  // 4. å‘é€é€šçŸ¥
  $.msg($.name, checkInResult.title, finalContent);
}

/**
 * æž„å»ºæ–‡æ¡ˆ
 */
function buildFinalContent(checkInRes, serverLogs) {
  const logs = serverLogs || [];
  
  // èŽ·å– UserID
  let userId = $.getdata(KEY_USER_ID) || "æœªçŸ¥";
  if (logs.length > 0 && logs[0].user_id) {
    userId = logs[0].user_id;
    $.setdata(String(userId), KEY_USER_ID);
  }

  // æž„é€ â€œæœ€æ–°ä¸€æ¡â€è®°å½•
  let currentLog = null;
  const isServerUpdated = logs.length > 0 && 
                          logs[0].change_type === "ç­¾åˆ°" && 
                          isToday(logs[0].created_at);

  if (isServerUpdated) {
    currentLog = logs[0];
  } else if (checkInRes.success) {
    currentLog = {
      created_at: getNowStr(),
      points: checkInRes.points,
      remark: checkInRes.raw_msg || "ç­¾åˆ°æˆåŠŸ",
      user_id: userId
    };
    logs.unshift(currentLog);
  } else {
    currentLog = logs[0] || { created_at: "", points: 0, remark: "æ— è®°å½•" };
  }

  const lines = [];
  
  // ç¬¬ä¸€è¡Œæ¶ˆæ¯
  const topMsg = checkInRes.raw_msg || checkInRes.message;
  lines.push(topMsg); 
  lines.push("");

  // è¯¦ç»†ä¿¡æ¯
  lines.push(`ç”¨æˆ·IDï¼š${userId}`);
  lines.push(`æœ€è¿‘ç­¾åˆ°ï¼š${formatTime(currentLog.created_at)}`);
  lines.push(`æœ¬æ¬¡èŽ·å¾—ï¼š+${currentLog.points} ç§¯åˆ†`);
  lines.push(`è¯´æ˜Žï¼š${currentLog.remark}`);
  lines.push("");
  lines.push("æœ€è¿‘ç­¾åˆ°è®°å½•ï¼š");

  // åˆ—è¡¨
  logs.slice(0, 5).forEach(log => {
    const time = formatTime(log.created_at);
    const pts = log.points;
    const remark = log.remark || log.change_type || "ç­¾åˆ°";
    lines.push(`- ${time}ï¼š+${pts}ï¼ˆ${remark}ï¼‰`);
  });

  return lines.join("\n");
}

/**
 * ç­¾åˆ°åŠ¨ä½œ
 */
async function doCheckIn(cookie) {
  const headers = buildHeaders(cookie);
  headers['Content-Type'] = 'application/json';
  
  const options = {
    url: API_CHECKIN,
    method: "POST",
    headers: headers,
    body: "{}"
  };

  return new Promise(resolve => {
    $.post(options, (err, resp, data) => {
      try {
        if (err) throw new Error("ç½‘ç»œè¯·æ±‚å¤±è´¥");
        
        // å…¼å®¹æ€§å¤„ç†ï¼šå¦‚æžœ data æ˜¯å¯¹è±¡åˆ™ç›´æŽ¥ç”¨ï¼Œå¦‚æžœæ˜¯å­—ç¬¦ä¸²åˆ™è§£æž
        let res = {};
        if (typeof data === 'string') {
            try { res = JSON.parse(data); } catch (e) { res = { message: data }; }
        } else {
            res = data || {};
        }

        const msg = res.message || "";
        const pointsMatch = msg.match(/(\d+)\s*ç§¯åˆ†/);
        const gainedPoints = pointsMatch ? parseInt(pointsMatch[1], 10) : 0;

        if (resp.status === 200 || resp.status === 201) {
          resolve({ 
            success: true, isRepeated: false, points: gainedPoints, 
            title: "âœ… ç­¾åˆ°æˆåŠŸ", message: msg, raw_msg: msg 
          });
        } else if (resp.status === 400) {
          if (msg.includes("å·²ç»ç­¾åˆ°") || msg.includes("checked in")) {
            resolve({ 
              success: false, isRepeated: true, points: 0, 
              title: "ðŸŸ¢ ç­¾åˆ°æˆåŠŸ", message: msg, raw_msg: msg 
            });
          } else {
            resolve({ success: false, points: 0, title: "âš ï¸ ç­¾åˆ°å¤±è´¥", message: msg, raw_msg: msg });
          }
        } else if (resp.status === 401 || resp.status === 403) {
           resolve({ success: false, points: 0, title: "ðŸ”´ Cookie å¤±æ•ˆ", message: "Token å·²è¿‡æœŸ", raw_msg: "Token Invalid" });
        } else {
           resolve({ success: false, points: 0, title: "âŒ æœªçŸ¥é”™è¯¯", message: msg, raw_msg: msg });
        }
      } catch (e) {
        console.log("ç­¾åˆ°è§£æžé”™è¯¯: " + e);
        resolve({ success: false, points: 0, title: "âŒ è„šæœ¬å¼‚å¸¸", message: e.message, raw_msg: "Script Error" });
      }
    });
  });
}

/**
 * æ‹‰å–æ—¥å¿—åŠ¨ä½œ
 */
async function fetchPointsLog(cookie) {
  const options = {
    url: API_LOGS,
    method: "GET",
    headers: buildHeaders(cookie)
  };

  return new Promise(resolve => {
    $.get(options, (err, resp, data) => {
      if (err) { resolve([]); return; }
      try {
        let json = {};
        if (typeof data === 'string') {
           json = JSON.parse(data);
        } else {
           json = data;
        }
        
        if (json && json.data && Array.isArray(json.data.list)) {
          resolve(json.data.list);
        } else {
          resolve([]);
        }
      } catch (e) { resolve([]); }
    });
  });
}

// --- è¾…åŠ©å·¥å…· ---
function getNowStr() {
  const now = new Date();
  const offset = now.getTimezoneOffset() * 60000;
  const local = new Date(now.getTime() - offset);
  return local.toISOString().replace("Z", "");
}

function formatTime(isoStr) {
  if (!isoStr) return "æœªçŸ¥æ—¶é—´";
  return isoStr.replace("T", " ").replace(/\.\d+Z?$/, "").replace(/\+\d{2}:\d{2}$/, "").substring(0, 19);
}

function isToday(isoStr) {
  if (!isoStr) return false;
  const logDate = isoStr.slice(0, 10);
  const nowDate = getNowStr().slice(0, 10);
  return logDate === nowDate;
}

// Cookie æŠ“å–
async function captureCookie() {
  const url = $request.url;
  if (url.includes("/user/checkin") || url.includes("points-logs")) return;
  const h = $request.headers;
  const cookie = h['Cookie'] || h['cookie'];
  if (cookie && cookie.includes("token=")) {
    const old = $.getdata(KEY_COOKIE);
    if (cookie !== old) {
      $.setdata(cookie, KEY_COOKIE);
      const ua = h['User-Agent'] || h['user-agent'];
      const ref = h['Referer'] || h['referer'];
      if(ua) $.setdata(ua, KEY_UA);
      if(ref) $.setdata(ref, KEY_REFERER);
      $.msg($.name, "ðŸŽ‰ Cookie æ›´æ–°", "èŽ·å–æˆåŠŸ");
    }
  }
}

function buildHeaders(cookie) {
  const ua = $.getdata(KEY_UA) || "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1";
  const referer = $.getdata(KEY_REFERER) || `https://${DOMAIN}/`;
  const token = (cookie.match(/token=([^;]+)/) || [])[1] || "";
  return { 'User-Agent': ua, 'Referer': referer, 'Origin': `https://${DOMAIN}`, 'Cookie': cookie, 'Authorization': `Bearer ${token}` };
}

// --- é€šç”¨å…¼å®¹æ¨¡å— (ä»Ž chavy/NobyDa ç§»æ¤ï¼Œæœ€ç¨³ç‰ˆæœ¬) ---
function Env(t,e){"undefined"!=typeof process&&JSON.stringify(process.env).indexOf("GITHUB")>-1&&process.exit(0);class s{constructor(t){this.env=t}write(t,e){switch(this.env){case"Surge":return $persistentStore.write(t,e);case"Quantumult X":return $prefs.setValueForKey(t,e);case"Loon":return $persistentStore.write(t,e)}}read(t){switch(this.env){case"Surge":return $persistentStore.read(t);case"Quantumult X":return $prefs.valueForKey(t);case"Loon":return $persistentStore.read(t)}}delete(t){switch(this.env){case"Surge":return $persistentStore.write(null,t);case"Quantumult X":return $prefs.removeValueForKey(t);case"Loon":return $persistentStore.write(null,t)}}post(t,e=null){const s=e?{url:t,...e}:t;if(e&&e.body&&!s.body&&(s.body=e.body),"Loon"===this.env||"Surge"===this.env)$httpClient.post(s,(t,e,s)=>{e.body=s,e.statusCode=e.status,this.done(e)});else if("Quantumult X"===this.env){const t=require("config");t.method="POST",t.url=s.url,t.headers=s.headers,t.body=s.body,$task.fetch(t).then(t=>{t.status=t.statusCode,this.done(t)},t=>{this.done(null)})}}get(t,e=null){const s=e?{url:t,...e}:t;if("Loon"===this.env||"Surge"===this.env)$httpClient.get(s,(t,e,s)=>{e.body=s,e.statusCode=e.status,this.done(e)});else if("Quantumult X"===this.env){const t=require("config");t.method="GET",t.url=s.url,t.headers=s.headers,$task.fetch(t).then(t=>{t.status=t.statusCode,this.done(t)},t=>{this.done(null)})}}}return new class{constructor(t,s){this.name=t,this.http=new class{post(t){return new Promise((e,s)=>{new Env("Loon").post(t,(t,r,n)=>{t?s(t):e(r)})})}get(t){return new Promise((e,s)=>{new Env("Loon").get(t,(t,r,n)=>{t?s(t):e(r)})})}},this.data=null,this.dataFile="box.dat",this.logs=[],this.isSurge="undefined"!=typeof $httpClient&&"undefined"==typeof $loon,this.isQuantumultX="undefined"!=typeof $task,this.isLoon="undefined"!=typeof $loon,this.isNode="undefined"!=typeof module&&!!module.exports,this.logSeparator="\n"}getdata(t){if(this.isLoon||this.isSurge)return new Env("Loon").read(t);if(this.isQuantumultX)return new Env("Quantumult X").read(t)}setdata(t,e){if(this.isLoon||this.isSurge)return new Env("Loon").write(t,e);if(this.isQuantumultX)return new Env("Quantumult X").write(t,e)}msg(t,e,s){this.isLoon&&$notification.post(t,e,s),this.isSurge&&$notification.post(t,e,s),this.isQuantumultX&&$notify(t,e,s),this.logs.push(t,e,s)}log(t){console.log(t),this.logs.push(t)}logErr(t){console.log(t),this.logs.push(t)}done(t={}){const e=(new Date).getTime();this.isLoon||this.isSurge?$done(t):this.isQuantumultX&&$done(t)}}(t,e)}
