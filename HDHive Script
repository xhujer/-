/*
HDHive è‡ªåŠ¨ç­¾åˆ°è„šæœ¬
Update: 2026-01-29
Author: ming
*/

const $ = new Env("HDHive");

// ========= å¸¸é‡ =========
const KEY_COOKIE = 'hdhive_cookie_v12';
const KEY_REFERER = 'hdhive_referer_v12';
const KEY_UA = 'hdhive_ua_v12';
const KEY_FLOW = 'hdhive_points_flow_v1';
const DOMAIN = 'hdhive.com';

// ========= å…¥å£ =========
(async () => {
  if (typeof $request !== "undefined") {
    await captureCookie();
  } else {
    await checkIn();
  }
})().catch(e => $.logErr(e)).finally(() => $.done());

// ========= æŠ“ Cookie =========
async function captureCookie() {
  const url = $request.url || "";
  if (!url.includes(DOMAIN)) return;
  if (url.includes("user/checkin")) return;

  const h = $request.headers || {};
  const cookie = getHeader(h, 'Cookie');
  const ua = getHeader(h, 'User-Agent');
  const referer = getHeader(h, 'Referer');

  if (!cookie || !cookie.includes("token=")) return;

  const old = $.getdata(KEY_COOKIE);
  if (cookie !== old) {
    $.setdata(cookie, KEY_COOKIE);
    if (ua) $.setdata(ua, KEY_UA);
    if (referer) $.setdata(referer, KEY_REFERER);
    $.msg("HDHive", "ðŸŽ‰ Cookie å·²æ›´æ–°", "å¯ä»¥å…³é—­è‡ªåŠ¨èŽ·å–å¼€å…³");
  }
}

// ========= ä¸»åŠ¨èŽ·å–ç§¯åˆ†æµæ°´ =========
async function activeFetchPointsFlow(headers) {
  const url = `https://${DOMAIN}/go-api/customer/points-logs?page=1&page_size=10`;
  try {
    const json = await httpGetJson(url, headers);
    const list = json?.data?.list;
    if (!Array.isArray(list) || !list.length) return null;

    const latest = list[0];
    const recent = list.slice(0, 3).map(x =>
      `- ${formatTime(x.created_at)}ï¼š+${x.points}ï¼ˆ${x.remark || x.change_type}ï¼‰`
    );

    const flow = {
      user_id: latest.user_id,
      latest_checkin: {
        time: latest.created_at,
        points: latest.points,
        remark: latest.remark || latest.change_type
      },
      recent_checkins: recent
    };

    $.setdata(JSON.stringify(flow), KEY_FLOW);
    return flow;
  } catch {
    return null;
  }
}

// ========= æž„å»ºå±•ç¤ºæ–‡æœ¬ =========
function buildFlowText(flow) {
  if (!flow) return "";
  const l = [];
  l.push(`ç”¨æˆ·IDï¼š${flow.user_id}`);
  l.push(`æœ€æ–°å˜åŠ¨ï¼š${formatTime(flow.latest_checkin.time)}`);
  l.push(`å˜åŠ¨æ•°å€¼ï¼š+${flow.latest_checkin.points} ç§¯åˆ†`);
  if (flow.latest_checkin.remark)
    l.push(`å†…å®¹æè¿°ï¼š${flow.latest_checkin.remark}`);
  if (flow.recent_checkins?.length) {
    l.push("");
    l.push("ðŸ“ è¿‘æœŸæµæ°´è®°å½•ï¼š");
    l.push(flow.recent_checkins.join("\n"));
  }
  return l.join("\n");
}

// ========= ç­¾åˆ° =========
async function checkIn() {
  const rawCookie = $.getdata(KEY_COOKIE);
  if (!rawCookie) {
    $.msg("HDHive", "âŒ æ— æ³•ç­¾åˆ°", "æœªèŽ·å– Cookie");
    return;
  }

  const token = parseCookie(rawCookie)['token'];
  if (!token) {
    $.msg("HDHive", "âŒ Cookie å¤±æ•ˆ", "ç¼ºå°‘ token");
    return;
  }

  const headers = {
    'User-Agent': $.getdata(KEY_UA) || 'Mozilla/5.0',
    'Accept': 'application/json, text/plain, */*',
    'Content-Type': 'application/json;charset=utf-8',
    'Origin': `https://${DOMAIN}`,
    'Referer': $.getdata(KEY_REFERER) || `https://${DOMAIN}/`,
    'Authorization': `Bearer ${token}`,
    'Cookie': rawCookie
  };

  const req = {
    url: `https://${DOMAIN}/api/customer/user/checkin`,
    method: "POST",
    headers,
    body: "{}"
  };

  return new Promise(resolve => {
    $.post(req, async (err, resp, data) => {
      if (err) {
        $.msg("HDHive", "âŒ ç½‘ç»œé”™è¯¯", "è¯·æ±‚å¤±è´¥");
        resolve();
        return;
      }

      let res = {};
      try { res = JSON.parse(data); } catch {}
      const msg = res.message || "";
      const checked =
        msg.includes("å·²ç»") || msg.includes("æ˜Žå¤©") || msg.toLowerCase().includes("checked");

      let flow = await activeFetchPointsFlow(headers);
      if (!flow) {
        try { flow = JSON.parse($.getdata(KEY_FLOW) || "null"); } catch {}
      }

      const flowText = flow ? "\n\n" + buildFlowText(flow) : "";

      $.msg(
        "HDHive",
        checked ? "ðŸŸ¢ ä»Šæ—¥å·²æ‰§è¡Œ" : "âœ… ç­¾åˆ°æˆåŠŸ",
        `${msg}${flowText}`
      );
      resolve();
    });
  });
}

// ========= å·¥å…· =========
function httpGetJson(url, headers) {
  return new Promise((resolve, reject) => {
    $.get({ url, headers }, (err, resp, data) => {
      if (err) return reject(err);
      try { resolve(JSON.parse(data)); } catch (e) { reject(e); }
    });
  });
}

function parseCookie(str) {
  const obj = {};
  str.split(';').forEach(p => {
    const i = p.indexOf('=');
    if (i > 0) obj[p.slice(0, i).trim()] = p.slice(i + 1).trim();
  });
  return obj;
}

function getHeader(h, k) {
  const key = k.toLowerCase();
  for (const i in h) {
    if (i.toLowerCase() === key) return h[i];
  }
  return null;
}

function formatTime(t) {
  return (t || "").replace("T", " ").replace(/\..*$/, "").replace(/\+\d\d:\d\d$/, "");
}

// ========= Env =========
function Env(name) {
  return {
    name,
    getdata: k => $persistentStore?.read(k),
    setdata: (v, k) => $persistentStore?.write(v, k),
    post: (o, c) => $httpClient?.post(o, c),
    get: (o, c) => $httpClient?.get(o, c),
    msg: (t, s, b) => {
      $notification?.post(t, s, b);
      console.log(`===${t}===\n${s}\n${b}`);
    },
    logErr: e => console.log(`â—ï¸${name}: ${e}`),
    done: () => $done?.({})
  };
}
