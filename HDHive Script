/*
HDHive è‡ªåŠ¨ç­¾åˆ° (å®šåˆ¶æ ¼å¼ä¿®å¤ç‰ˆ)
Update: 2026-01-16
Author: ming
Fix: ä¿®å¤ Env æ¨¡å—åœ¨ Loon ä¸‹æŠ¥é”™çš„é—®é¢˜
*/

const $ = new Env("HDHive");

// --- å˜é‡å®šä¹‰ ---
const KEY_COOKIE = 'hdhive_cookie_v12';
const KEY_REFERER = 'hdhive_referer_v12';
const KEY_UA = 'hdhive_ua_v12';
const KEY_USER_ID = 'hdhive_uid_v1';
const DOMAIN = 'hdhive.com';

// æŽ¥å£åœ°å€
const API_CHECKIN = `https://${DOMAIN}/api/customer/user/checkin`;
const API_LOGS = `https://${DOMAIN}/go-api/customer/points-logs?page=1&page_size=10`;

// --- ä¸»ç¨‹åºå…¥å£ ---
(async () => {
  if (typeof $request !== "undefined") {
    await captureCookie();
  } else {
    await main();
  }
})()
  .catch((e) => $.logErr(e))
  .finally(() => $.done());

// --- æ ¸å¿ƒé€»è¾‘ ---
async function main() {
  const cookie = $.getdata(KEY_COOKIE);
  if (!cookie) {
    $.msg($.name, "âŒ æ— æ³•æ‰§è¡Œ", `è¯·å…ˆè®¿é—® ${DOMAIN} ç™»å½•ä»¥èŽ·å– Cookie`);
    return;
  }

  // 1. æ‰§è¡Œç­¾åˆ°
  const checkInResult = await doCheckIn(cookie);
  
  // 2. å°è¯•æ‹‰å–æ—¥å¿—ï¼ˆå»¶è¿Ÿ2ç§’ä»¥ç¡®ä¿æ•°æ®å†™å…¥ï¼‰
  if (checkInResult.success || checkInResult.isRepeated) {
     await new Promise(r => setTimeout(r, 2000));
  }
  const serverLogs = await fetchPointsLog(cookie);

  // 3. æž„å»ºæ–‡æ¡ˆ
  const finalContent = buildFinalContent(checkInResult, serverLogs);
  
  // 4. å‘é€é€šçŸ¥
  $.msg($.name, checkInResult.title, finalContent);
}

/**
 * æž„å»ºæ–‡æ¡ˆ
 */
function buildFinalContent(checkInRes, serverLogs) {
  const logs = serverLogs || [];
  
  // èŽ·å– UserID
  let userId = $.getdata(KEY_USER_ID) || "æœªçŸ¥";
  if (logs.length > 0 && logs[0].user_id) {
    userId = logs[0].user_id;
    $.setdata(String(userId), KEY_USER_ID);
  }

  // æž„é€ â€œæœ€æ–°ä¸€æ¡â€è®°å½•
  let currentLog = null;
  const isServerUpdated = logs.length > 0 && 
                          logs[0].change_type === "ç­¾åˆ°" && 
                          isToday(logs[0].created_at);

  if (isServerUpdated) {
    currentLog = logs[0];
  } else if (checkInRes.success) {
    currentLog = {
      created_at: getNowStr(),
      points: checkInRes.points,
      remark: checkInRes.raw_msg || "ç­¾åˆ°æˆåŠŸ",
      user_id: userId
    };
    logs.unshift(currentLog);
  } else {
    currentLog = logs[0] || { created_at: "", points: 0, remark: "æ— è®°å½•" };
  }

  const lines = [];
  
  // ç¬¬ä¸€è¡Œæ¶ˆæ¯
  const topMsg = checkInRes.raw_msg || checkInRes.message;
  lines.push(topMsg); 
  lines.push("");

  // è¯¦ç»†ä¿¡æ¯
  lines.push(`ç”¨æˆ·IDï¼š${userId}`);
  lines.push(`æœ€è¿‘ç­¾åˆ°ï¼š${formatTime(currentLog.created_at)}`);
  lines.push(`æœ¬æ¬¡èŽ·å¾—ï¼š+${currentLog.points} ç§¯åˆ†`);
  lines.push(`è¯´æ˜Žï¼š${currentLog.remark}`);
  lines.push("");
  lines.push("æœ€è¿‘ç­¾åˆ°è®°å½•ï¼š");

  // åˆ—è¡¨
  logs.slice(0, 5).forEach(log => {
    const time = formatTime(log.created_at);
    const pts = log.points;
    const remark = log.remark || log.change_type || "ç­¾åˆ°";
    lines.push(`- ${time}ï¼š+${pts}ï¼ˆ${remark}ï¼‰`);
  });

  return lines.join("\n");
}

/**
 * ç­¾åˆ°åŠ¨ä½œ
 */
async function doCheckIn(cookie) {
  const headers = buildHeaders(cookie);
  headers['Content-Type'] = 'application/json';
  
  return new Promise(resolve => {
    $.post({
      url: API_CHECKIN,
      method: "POST",
      headers: headers,
      body: "{}"
    }, (err, resp, data) => {
      try {
        if (err) throw new Error("ç½‘ç»œè¯·æ±‚å¤±è´¥");
        let res = {};
        try { res = JSON.parse(data); } catch (e) { res = { message: data }; }
        const msg = res.message || "";
        
        const pointsMatch = msg.match(/(\d+)\s*ç§¯åˆ†/);
        const gainedPoints = pointsMatch ? parseInt(pointsMatch[1], 10) : 0;

        if (resp.status === 200 || resp.status === 201) {
          resolve({ 
            success: true, 
            isRepeated: false, 
            points: gainedPoints, 
            title: "âœ… ç­¾åˆ°æˆåŠŸ", 
            message: msg,
            raw_msg: msg
          });
        } else if (resp.status === 400) {
          if (msg.includes("å·²ç»ç­¾åˆ°") || msg.includes("checked in")) {
            resolve({ 
              success: false, 
              isRepeated: true, 
              points: 0, 
              title: "ðŸŸ¢ ç­¾åˆ°æˆåŠŸ", 
              message: msg,
              raw_msg: msg
            });
          } else {
            resolve({ success: false, points: 0, title: "âš ï¸ ç­¾åˆ°å¤±è´¥", message: msg, raw_msg: msg });
          }
        } else if (resp.status === 401 || resp.status === 403) {
           resolve({ success: false, points: 0, title: "ðŸ”´ Cookie å¤±æ•ˆ", message: "Token å·²è¿‡æœŸ", raw_msg: "Token Invalid" });
        } else {
           resolve({ success: false, points: 0, title: "âŒ æœªçŸ¥é”™è¯¯", message: msg, raw_msg: msg });
        }
      } catch (e) {
        resolve({ success: false, points: 0, title: "âŒ è„šæœ¬å¼‚å¸¸", message: e.message, raw_msg: "Script Error" });
      }
    });
  });
}

/**
 * æ‹‰å–æ—¥å¿—åŠ¨ä½œ
 */
async function fetchPointsLog(cookie) {
  return new Promise(resolve => {
    $.get({
      url: API_LOGS,
      method: "GET",
      headers: buildHeaders(cookie)
    }, (err, resp, data) => {
      if (err) { resolve([]); return; }
      try {
        const json = JSON.parse(data);
        if (json && json.data && Array.isArray(json.data.list)) {
          resolve(json.data.list);
        } else {
          resolve([]);
        }
      } catch (e) { resolve([]); }
    });
  });
}

// --- è¾…åŠ©å·¥å…· ---
function getNowStr() {
  const now = new Date();
  const offset = now.getTimezoneOffset() * 60000;
  const local = new Date(now.getTime() - offset);
  return local.toISOString().replace("Z", "");
}

function formatTime(isoStr) {
  if (!isoStr) return "æœªçŸ¥æ—¶é—´";
  return isoStr.replace("T", " ").replace(/\.\d+Z?$/, "").replace(/\+\d{2}:\d{2}$/, "").substring(0, 19);
}

function isToday(isoStr) {
  if (!isoStr) return false;
  const logDate = isoStr.slice(0, 10);
  const nowDate = getNowStr().slice(0, 10);
  return logDate === nowDate;
}

// Cookie æŠ“å–
async function captureCookie() {
  const url = $request.url;
  if (url.includes("/user/checkin") || url.includes("points-logs")) return;
  
  const h = $request.headers;
  const cookie = h['Cookie'] || h['cookie'];
  if (cookie && cookie.includes("token=")) {
    const old = $.getdata(KEY_COOKIE);
    if (cookie !== old) {
      $.setdata(cookie, KEY_COOKIE);
      const ua = h['User-Agent'] || h['user-agent'];
      const ref = h['Referer'] || h['referer'];
      if(ua) $.setdata(ua, KEY_UA);
      if(ref) $.setdata(ref, KEY_REFERER);
      $.msg($.name, "ðŸŽ‰ Cookie æ›´æ–°", "èŽ·å–æˆåŠŸï¼Œè¯·åœ¨æ’ä»¶é…ç½®ä¸­å…³é—­è‡ªåŠ¨èŽ·å–å¼€å…³");
    }
  }
}

function buildHeaders(cookie) {
  const ua = $.getdata(KEY_UA) || "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1";
  const referer = $.getdata(KEY_REFERER) || `https://${DOMAIN}/`;
  const token = (cookie.match(/token=([^;]+)/) || [])[1] || "";
  return { 'User-Agent': ua, 'Referer': referer, 'Origin': `https://${DOMAIN}`, 'Cookie': cookie, 'Authorization': `Bearer ${token}` };
}

// --- Env æ¨¡å— (Loon ä¸“ç”¨ç¨³å®šç‰ˆ) ---
function Env(name) {
  return {
    name: name,
    // ç›´æŽ¥ä½¿ç”¨ $persistentStoreï¼Œé¿å…é€’å½’é”™è¯¯
    getdata: (key) => {
      if (typeof $persistentStore !== "undefined") return $persistentStore.read(key);
      return null;
    },
    setdata: (val, key) => {
      if (typeof $persistentStore !== "undefined") return $persistentStore.write(val, key);
      return null;
    },
    msg: (title, subtitle, body) => {
      if (typeof $notification !== "undefined") $notification.post(title, subtitle, body);
      console.log(`===${title}===\n${subtitle}\n${body}`);
    },
    log: (message) => console.log(`[${name}] ${message}`),
    logErr: (err) => console.log(`[${name}] â—ï¸Error: ${err}`),
    post: (options, callback) => {
      if (typeof $httpClient !== "undefined") {
        $httpClient.post(options, callback);
      }
    },
    get: (options, callback) => {
      if (typeof $httpClient !== "undefined") {
        $httpClient.get(options, callback);
      }
    },
    done: () => {
      if (typeof $done !== "undefined") $done({});
    }
  };
}
