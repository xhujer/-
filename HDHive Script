/*
HDHive è‡ªåŠ¨ç­¾åˆ°è„šæœ¬ + ä¸»åŠ¨èŽ·å–ç§¯åˆ†æµæ°´ (Active Fetching)
Update: 2026-01-16 + Active Fetching
Author: ming (modified)
*/

const $ = new Env("HDHive");

// å˜é‡å®šä¹‰
const KEY_COOKIE = 'hdhive_cookie_v12';
const KEY_REFERER = 'hdhive_referer_v12';
const KEY_UA = 'hdhive_ua_v12';
const KEY_FLOW = 'hdhive_points_flow_v1'; // ç¼“å­˜ç­¾åˆ°è®°å½•ï¼ˆç§¯åˆ†æµæ°´ï¼‰
const DOMAIN = 'hdhive.com';

(async () => {
  // åœºæ™¯1ï¼šhttp-response æŠ“å–ç§¯åˆ†å˜åŠ¨æ—¥å¿— (JSON)
  if (typeof $request !== "undefined" && typeof $response !== "undefined") {
    await captureFlowFromResponse();
  }
  // åœºæ™¯2ï¼šhttp-request æŠ“å– Cookie
  else if (typeof $request !== "undefined") {
    await capture();
  }
  // åœºæ™¯3ï¼šCron å®šæ—¶ä»»åŠ¡æ‰§è¡Œç­¾åˆ°
  else {
    await checkIn();
  }
})().catch((e) => $.logErr(e)).finally(() => $.done());

/** ========= 1. æŠ“å– Cookie ========= */
async function capture() {
  const url = $request.url || "";
  // æŽ’é™¤ç­¾åˆ°æŽ¥å£ï¼Œé˜²æ­¢å¾ªçŽ¯æˆ–é”™è¯¯æŠ“å–
  if (url.indexOf("user/checkin") > -1 || url.indexOf("/api/customer/user/checkin") > -1) return;
  if (url.indexOf(DOMAIN) === -1) return;

  const h = $request.headers || {};
  const cookie = getHeader(h, 'Cookie');
  const ua = getHeader(h, 'User-Agent');
  const referer = getHeader(h, 'Referer');

  // å¿…é¡»åŒ…å« token æ‰æ˜¯æœ‰æ•ˆ Cookie
  if (cookie && cookie.indexOf("token=") > -1) {
    if (cookie.length < 20) return;
    const oldCookie = $.getdata(KEY_COOKIE);
    if (cookie !== oldCookie) {
      $.setdata(cookie, KEY_COOKIE);
      if (ua) $.setdata(ua, KEY_UA);
      if (referer) $.setdata(referer, KEY_REFERER);
      $.msg("HDHive", "ðŸŽ‰ æŠ“å–æˆåŠŸ", "Cookieå·²æ›´æ–°ï¼Œå»ºè®®å…³é—­è„šæœ¬çš„[è‡ªåŠ¨èŽ·å–]å¼€å…³");
    }
  }
}

/** ========= 2. æŠ“å–ç§¯åˆ†æµæ°´ (Points Logs) ========= */
async function captureFlowFromResponse() {
  try {
    const url = $request.url || "";

    // ç²¾å‡†åŒ¹é… API åœ°å€
    if (!url.includes("hdhive.com/go-api/customer/points-logs")) return;

    // ç¡®ä¿æ˜¯ JSON å“åº”
    const ct = getHeader($response.headers || {}, "content-type") || "";
    if (!ct.toLowerCase().includes("application/json")) return;

    const body = $response.body || "";
    if (!body) return;

    let j;
    try { j = JSON.parse(body); } catch (e) { return; }

    const flow = parsePointsFlow(j);
    if (!flow) return;

    // ç¼“å­˜ç­–ç•¥ï¼špage=1 æ€»æ˜¯è¦†ç›–ï¼›page>1 ä»…åœ¨æ— ç¼“å­˜æ—¶å†™å…¥
    cacheFlowPreferPage1($, KEY_FLOW, url, flow);

  } catch (e) {
    $.logErr(e);
  }
}

function getQueryParam(url, key) {
  const m = url.match(new RegExp(`[?&]${key}=([^&]+)`));
  return m ? decodeURIComponent(m[1]) : "";
}

function cacheFlowPreferPage1($, key, url, flowObj) {
  const pageStr = getQueryParam(url, "page") || "1";
  const page = parseInt(pageStr, 10);
  const hasOld = !!$.getdata(key);

  if (page === 1) {
    $.setdata(JSON.stringify(flowObj), key);
    $.log("ðŸ“Œ å·²æ›´æ–°ç­¾åˆ°è®°å½•ç¼“å­˜ (Page 1)");
    return;
  }

  if (!hasOld) {
    $.setdata(JSON.stringify(flowObj), key);
    $.log(`ðŸ“Œ å·²åˆå§‹åŒ–ç­¾åˆ°è®°å½•ç¼“å­˜ (Page ${page})`);
  }
}

function formatTime(iso) {
  return (iso || "").replace("T", " ").replace(/\+\d\d:\d\d$/, "");
}

function parsePointsFlow(resJson) {
  const list = resJson?.data?.list;
  if (!resJson?.success || !Array.isArray(list) || !list.length) return null;

  // å¯»æ‰¾æœ€è¿‘ä¸€æ¡ç±»åž‹ä¸ºâ€œç­¾åˆ°â€çš„è®°å½•
  const latestCheckin = list.find(x => x && x.change_type === "ç­¾åˆ°") || null;
  if (!latestCheckin) return null;

  // æå–æœ€è¿‘3æ¡ç­¾åˆ°è®°å½•ç”¨äºŽå±•ç¤º
  const recentCheckins = list
    .filter(x => x && x.change_type === "ç­¾åˆ°")
    .slice(0, 3)
    .map(x => `- ${formatTime(x.created_at)}ï¼š+${x.points}ï¼ˆ${x.remark || "ç­¾åˆ°"}ï¼‰`);

  return {
    user_id: latestCheckin.user_id,
    latest_checkin: {
      points: latestCheckin.points,
      time: latestCheckin.created_at,
      remark: latestCheckin.remark
    },
    recent_checkins: recentCheckins
  };
}

function buildFlowText(flow) {
  if (!flow) return "";
  const lines = [];
  lines.push(`ç”¨æˆ·IDï¼š${flow.user_id ?? "æœªçŸ¥"}`);
  lines.push(`æœ€è¿‘ç­¾åˆ°ï¼š${formatTime(flow.latest_checkin?.time) || "æœªçŸ¥"}`);
  if (flow.latest_checkin?.points != null) lines.push(`ä¸Šæ¬¡èŽ·å¾—ï¼š+${flow.latest_checkin.points} ç§¯åˆ†`);
  if (flow.latest_checkin?.remark) lines.push(`è¯´æ˜Žï¼š${flow.latest_checkin.remark}`);
  if (flow.recent_checkins?.length) {
    lines.push("");
    lines.push("ðŸ“ æœ€è¿‘è®°å½•ï¼š");
    lines.push(flow.recent_checkins.join("\n"));
  }
  return lines.join("\n");
}

/** ========= 2.1 ä¸»åŠ¨èŽ·å–ç§¯åˆ†æµæ°´ (Active Fetch) ========= */
async function activeFetchPointsFlow(headers) {
  // ä¼˜å…ˆå°è¯• go-apiï¼ˆä½ æŠ“åŒ…ç”¨çš„ï¼‰ï¼Œä¸è¡Œå†å›žé€€ apiï¼ˆæœ‰äº›ç«™ç‚¹ä¼šåˆ‡æ¢ï¼‰
  const urls = [
    `https://${DOMAIN}/go-api/customer/points-logs?page=1`,
    `https://${DOMAIN}/api/customer/points-logs?page=1`
  ];

  for (const url of urls) {
    const flow = await httpGetJson(url, headers).then(parsePointsFlow).catch(() => null);
    if (flow) {
      // ä¸»åŠ¨èŽ·å–åˆ°å°±å†™ä¸€ä»½ç¼“å­˜ï¼Œæ–¹ä¾¿åŽç»­å…œåº•æ˜¾ç¤º
      $.setdata(JSON.stringify(flow), KEY_FLOW);
      return flow;
    }
  }
  return null;
}

function httpGetJson(url, headers) {
  return new Promise((resolve, reject) => {
    const req = { url, method: "GET", headers };
    // Surge/Loon: $httpClient.get
    if ($.get) {
      $.get(req, (err, resp, data) => {
        if (err) return reject(err);
        try { resolve(JSON.parse(data)); } catch (e) { reject(e); }
      });
      return;
    }

    // å…¼å®¹ï¼šå¦‚æžœ Env æ²¡å°è£… getï¼Œåˆ™ç”¨ post çš„ fallbackï¼ˆæžå°‘è§ï¼‰
    if ($.post) {
      // æœ‰äº›çŽ¯å¢ƒæ²¡æœ‰ getï¼Œå°±ç”¨ post ä¹Ÿè®¸ä¸è¡Œï¼›è¿™é‡Œå°½é‡å…œåº•
      $.post(req, (err, resp, data) => {
        if (err) return reject(err);
        try { resolve(JSON.parse(data)); } catch (e) { reject(e); }
      });
      return;
    }

    reject(new Error("No HTTP client available"));
  });
}

/** ========= 3. æ‰§è¡Œç­¾åˆ° (Cron) ========= */
async function checkIn() {
  const rawCookie = $.getdata(KEY_COOKIE);
  const referer = $.getdata(KEY_REFERER) || `https://${DOMAIN}/`;
  const ua = $.getdata(KEY_UA) || "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1";

  if (!rawCookie) {
    $.msg("HDHive", "âŒ æ— æ³•ç­¾åˆ°", `æ— Cookieï¼Œè¯·å…ˆè®¿é—® ${DOMAIN} è¿›è¡Œç™»å½•`);
    return;
  }

  const cookieObj = parseCookie(rawCookie);
  const token = cookieObj['token']; // å…³é”®ï¼šä»ŽCookieæå–Token
  const csrfToken = cookieObj['csrf_access_token'];

  if (!token) {
    $.msg("HDHive", "âŒ Cookieå¤±æ•ˆ", "Cookieä¸­ç¼ºå°‘tokenï¼Œè¯·é‡æ–°ç™»å½•ç½‘é¡µæŠ“å–");
    return;
  }

  const headers = {
    'User-Agent': ua,
    'Accept': 'application/json, text/plain, */*',
    'Content-Type': 'application/json;charset=utf-8',
    'Origin': `https://${DOMAIN}`,
    'Referer': referer,
    'Authorization': `Bearer ${token}`, // HDHive éœ€è¦ Bearer Token
    'Cookie': rawCookie
  };
  if (csrfToken) headers['x-csrf-token'] = csrfToken;

  const req = {
    url: `https://${DOMAIN}/api/customer/user/checkin`,
    method: "POST",
    headers: headers,
    body: "{}" // ç©ºJSONå¯¹è±¡
  };

  return new Promise(resolve => {
    $.post(req, async (err, resp, data) => {
      if (err) {
        $.msg("HDHive", "âŒ ç½‘ç»œé”™è¯¯", "æ— æ³•è¿žæŽ¥æœåŠ¡å™¨");
        resolve();
        return;
      }

      let resJson = {};
      try { resJson = JSON.parse(data); } catch (e) {}

      const msg = resJson.message || "";
      const looksChecked =
        msg.includes("å·²ç»ç­¾åˆ°") ||
        msg.includes("æ˜Žå¤©å†æ¥") ||
        msg.toLowerCase().includes("checked");

      // ======== Active Fetchï¼šæ— è®ºæˆåŠŸ/å·²ç­¾åˆ°ï¼Œéƒ½ä¸»åŠ¨æ‹‰ä¸€æ¬¡ç§¯åˆ†æµæ°´ ========
      let activeFlow = null;
      try { activeFlow = await activeFetchPointsFlow(headers); } catch (e) {}
      let flowText = activeFlow ? ("\n\n" + buildFlowText(activeFlow)) : "";

      // å¦‚æžœä¸»åŠ¨æ‹‰å–å¤±è´¥ï¼Œå°±å›žé€€ç”¨æ—§ç¼“å­˜
      if (!flowText) {
        let cached = null;
        try { cached = JSON.parse($.getdata(KEY_FLOW) || "null"); } catch(e) {}
        flowText = cached ? ("\n\n" + buildFlowText(cached)) : "";
      }

      if (resp.status === 200 || resp.status === 201) {
        if (looksChecked) {
          $.msg("HDHive", "ðŸŸ¢ ä»Šæ—¥å·²ç­¾åˆ°", `${msg}${flowText}`);
        } else {
          $.msg("HDHive", "âœ… ç­¾åˆ°æˆåŠŸ", `${msg || "èŽ·å¾—ç§¯åˆ†"}${flowText}`);
        }
      } else if (resp.status === 400) {
        if (looksChecked) {
          $.msg("HDHive", "ðŸŸ¢ ä»Šæ—¥å·²ç­¾åˆ°", `${msg || "æ— éœ€é‡å¤æ‰§è¡Œ"}${flowText}`);
        } else {
          $.msg("HDHive", "âš ï¸ ç­¾åˆ°å¼‚å¸¸", `${msg || "è¯·æ±‚å¼‚å¸¸"}${flowText}`);
        }
      } else if (resp.status === 401 || resp.status === 403) {
        $.msg("HDHive", "ðŸ”´ Cookieè¿‡æœŸ", "Tokenå·²å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•ç½‘é¡µæŠ“å–");
      } else {
        $.msg("HDHive", "âŒ æœªçŸ¥é”™è¯¯", `çŠ¶æ€ç  ${resp.status}${msg ? `ï¼š${msg}` : ""}`);
      }
      resolve();
    });
  });
}

// è¾…åŠ©å‡½æ•°
function parseCookie(str) {
  const list = {};
  if (!str) return list;
  str.split(';').forEach(i => {
    const parts = i.split('=');
    if (parts.length >= 2) list[parts[0].trim()] = parts.slice(1).join('=').trim();
  });
  return list;
}

function getHeader(headers, key) {
  if (!headers) return null;
  const lowerKey = key.toLowerCase();
  for (const k in headers) {
    if (k.toLowerCase() === lowerKey) return headers[k];
  }
  return null;
}

// Loon/Surge å…¼å®¹å±‚ï¼ˆæ–°å¢ž $.get ç”¨äºŽ Active Fetchï¼‰
function Env(name) {
  return {
    name: name,
    getdata: (k) => typeof $persistentStore !== "undefined" ? $persistentStore.read(k) : null,
    setdata: (v, k) => typeof $persistentStore !== "undefined" ? $persistentStore.write(v, k) : null,
    msg: (t, s, b) => {
      if (typeof $notification !== "undefined") $notification.post(t, s, b);
      console.log(`===${t}===\n${s}\n${b}`);
    },
    post: (o, c) => typeof $httpClient !== "undefined" ? $httpClient.post(o, c) : null,
    get: (o, c) => typeof $httpClient !== "undefined" ? $httpClient.get(o, c) : null,
    log: (l) => console.log(`[${name}] ${l}`),
    logErr: (e) => console.log(`â—ï¸${name} Error: ${e}`),
    done: () => typeof $done !== "undefined" ? $done({}) : null
  };
}