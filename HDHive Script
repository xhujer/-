/*
HDHive è‡ªåŠ¨ç­¾åˆ° (å®šåˆ¶æ ¼å¼ç‰ˆ)
Update: 2026-01-16
Author: ming
Features: è‡ªåŠ¨ç­¾åˆ° + ä¸»åŠ¨æ‹‰å– + ä¸¥æ ¼æŒ‡å®šæ–‡æ¡ˆæ ¼å¼
*/

const $ = new Env("HDHive");

// --- é…ç½®åŒºåŸŸ ---
const KEY_COOKIE = 'hdhive_cookie_v12';
const KEY_REFERER = 'hdhive_referer_v12';
const KEY_UA = 'hdhive_ua_v12';
const DOMAIN = 'hdhive.com';

// æŽ¥å£åœ°å€
const API_CHECKIN = `https://${DOMAIN}/api/customer/user/checkin`;
const API_LOGS = `https://${DOMAIN}/go-api/customer/points-logs?page=1&page_size=10`;

(async () => {
  if (typeof $request !== "undefined") {
    await captureCookie();
  } else {
    await main();
  }
})()
  .catch((e) => $.logErr(e))
  .finally(() => $.done());

async function main() {
  const cookie = $.getdata(KEY_COOKIE);
  if (!cookie) {
    $.msg($.name, "âŒ æ— æ³•æ‰§è¡Œ", `è¯·å…ˆè®¿é—® ${DOMAIN} ç™»å½•ä»¥èŽ·å– Cookie`);
    return;
  }

  // 1. æ‰§è¡Œç­¾åˆ°
  const checkInResult = await doCheckIn(cookie);
  
  // 2. åªæœ‰ç­¾åˆ°æˆåŠŸæˆ–é‡å¤ç­¾åˆ°æ—¶ï¼Œæ‰åŽ»æ‹‰å–è¯¦æƒ…
  if (checkInResult.success || checkInResult.isRepeated) {
    // ç¨å¾®ç­‰å¾…æœåŠ¡å™¨å¤„ç†ï¼ˆ2ç§’ï¼‰
    await new Promise(r => setTimeout(r, 2000)); 
    const serverLogs = await fetchPointsLog(cookie);
    
    // 3. ç”Ÿæˆä¸¥æ ¼æ ¼å¼çš„æ–‡æ¡ˆ
    const finalContent = buildFinalContent(checkInResult, serverLogs);
    $.msg($.name, checkInResult.title, finalContent);
  } else {
    // é”™è¯¯æƒ…å†µç›´æŽ¥å‘é€ç®€å•é€šçŸ¥
    $.msg($.name, checkInResult.title, checkInResult.message);
  }
}

/**
 * æ ¸å¿ƒï¼šæž„å»ºç¬¦åˆè¦æ±‚çš„æ–‡æ¡ˆ
 */
function buildFinalContent(checkInRes, serverLogs) {
  const logs = serverLogs || [];
  
  // å°è¯•èŽ·å– UserID
  let userId = logs.length > 0 ? logs[0].user_id : "æœªçŸ¥";
  
  // æž„é€ â€œæœ€æ–°ä¸€æ¡â€æ•°æ®
  // é€»è¾‘ï¼šå¦‚æžœæœåŠ¡å™¨ç¬¬ä¸€æ¡æ—¥å¿—æ˜¯ä»Šå¤©çš„ç­¾åˆ°ï¼Œå°±ç”¨æœåŠ¡å™¨çš„ï¼›
  // å¦åˆ™ï¼ˆæœåŠ¡å™¨å»¶è¿Ÿï¼‰ï¼Œç”¨å½“å‰ç­¾åˆ°ç»“æžœæž„é€ ä¸€æ¡å‡çš„ï¼Œæ’åœ¨æœ€å‰é¢ã€‚
  
  let currentLog = null;
  
  // ç®€å•çš„æ—¥æœŸæ¯”å¯¹
  const isServerUpdated = logs.length > 0 && 
                          logs[0].change_type === "ç­¾åˆ°" && 
                          isToday(logs[0].created_at);

  if (isServerUpdated) {
    // æƒ…å†µAï¼šæœåŠ¡å™¨å·²æ›´æ–°ï¼Œç›´æŽ¥ç”¨
    currentLog = logs[0];
  } else if (checkInRes.success) {
    // æƒ…å†µBï¼šæœåŠ¡å™¨æ²¡æ›´æ–°ï¼Œä½†åˆšæ‰ç­¾åˆ°æˆåŠŸäº† -> æ‰‹åŠ¨æž„é€ 
    currentLog = {
      created_at: new Date().toISOString(),
      points: checkInRes.points,
      remark: checkInRes.message.replace("æœåŠ¡ç«¯å›žåº”ï¼š", "") || "ç­¾åˆ°æˆåŠŸ",
      user_id: userId
    };
    // æŠŠå®ƒæ’åˆ°æ•°ç»„å¤´ï¼Œç”¨äºŽä¸‹æ–¹åˆ—è¡¨å±•ç¤º
    logs.unshift(currentLog);
  } else {
    // æƒ…å†µCï¼šæ²¡ç­¾åˆ°æˆåŠŸï¼Œä¹Ÿä¸æ˜¯æœ€æ–°çš„ -> å–æ—§çš„æœ€æ–°
    currentLog = logs[0] || {};
  }

  // æ ¼å¼åŒ–é¡¶éƒ¨ä¿¡æ¯
  const lines = [];
  // æ ‡é¢˜è¡Œï¼šç­¾åˆ°æˆåŠŸï¼ŒèŽ·å¾— 9 ç§¯åˆ†
  lines.push(checkInRes.message.replace("æœåŠ¡ç«¯å›žåº”ï¼š", "")); 
  lines.push("");
  lines.push(`ç”¨æˆ·IDï¼š${currentLog.user_id || userId}`);
  lines.push(`æœ€è¿‘ç­¾åˆ°ï¼š${formatTime(currentLog.created_at)}`);
  lines.push(`æœ¬æ¬¡èŽ·å¾—ï¼š+${currentLog.points || 0} ç§¯åˆ†`);
  lines.push(`è¯´æ˜Žï¼š${currentLog.remark || "æ— "}`);
  lines.push("");
  lines.push("æœ€è¿‘ç­¾åˆ°è®°å½•ï¼š");

  // æ ¼å¼åŒ–åˆ—è¡¨ (å–å‰5æ¡)
  logs.slice(0, 5).forEach(log => {
    // æ ¼å¼ï¼š- 2026-01-15 19:00:26ï¼š+10ï¼ˆç­¾åˆ°æˆåŠŸï¼ŒèŽ·å¾— 10 ç§¯åˆ†ï¼‰
    const time = formatTime(log.created_at);
    const pts = log.points;
    const remark = log.remark || log.change_type || "ç­¾åˆ°";
    lines.push(`- ${time}ï¼š+${pts}ï¼ˆ${remark}ï¼‰`);
  });

  return lines.join("\n");
}

/**
 * åŠ¨ä½œï¼šæ‰§è¡Œç­¾åˆ°
 */
async function doCheckIn(cookie) {
  const headers = buildHeaders(cookie);
  headers['Content-Type'] = 'application/json';
  
  const options = {
    url: API_CHECKIN,
    method: "POST",
    headers: headers,
    body: "{}"
  };

  return new Promise(resolve => {
    $.post(options, (err, resp, data) => {
      try {
        if (err) throw new Error("ç½‘ç»œè¯·æ±‚å¤±è´¥");
        let res = {};
        try { res = JSON.parse(data); } catch (e) { res = { message: data }; }
        const msg = res.message || "";
        
        // æå–ç§¯åˆ†æ•°å­—
        const pointsMatch = msg.match(/(\d+)\s*ç§¯åˆ†/);
        const gainedPoints = pointsMatch ? parseInt(pointsMatch[1], 10) : 0;

        if (resp.status === 200 || resp.status === 201) {
          resolve({ 
            success: true, 
            isRepeated: false, 
            points: gainedPoints,
            title: "âœ… ç­¾åˆ°æˆåŠŸ", 
            message: msg 
          });
        } else if (resp.status === 400) {
          if (msg.includes("å·²ç»ç­¾åˆ°") || msg.includes("checked in")) {
            resolve({ 
              success: false, 
              isRepeated: true, 
              points: 0,
              title: "ðŸŸ¢ ä»Šæ—¥å·²ç­¾åˆ°", 
              message: msg 
            });
          } else {
            resolve({ success: false, points: 0, title: "âš ï¸ ç­¾åˆ°å¤±è´¥", message: msg });
          }
        } else if (resp.status === 401 || resp.status === 403) {
           resolve({ success: false, points: 0, title: "ðŸ”´ Cookie å¤±æ•ˆ", message: "Token å·²è¿‡æœŸ" });
        } else {
           resolve({ success: false, points: 0, title: "âŒ æœªçŸ¥é”™è¯¯", message: `çŠ¶æ€ç : ${resp.status} ${msg}` });
        }
      } catch (e) {
        resolve({ success: false, points: 0, title: "âŒ è„šæœ¬å¼‚å¸¸", message: e.message });
      }
    });
  });
}

async function fetchPointsLog(cookie) {
  const options = {
    url: API_LOGS,
    method: "GET",
    headers: buildHeaders(cookie)
  };

  return new Promise(resolve => {
    $.get(options, (err, resp, data) => {
      if (err) { resolve([]); return; }
      try {
        const json = JSON.parse(data);
        if (json && json.data && Array.isArray(json.data.list)) {
          resolve(json.data.list);
        } else {
          resolve([]);
        }
      } catch (e) { resolve([]); }
    });
  });
}

// è¾…åŠ©ï¼šæ—¶é—´æ ¼å¼åŒ–
function formatTime(isoStr) {
  if (!isoStr) return "æœªçŸ¥æ—¶é—´";
  return isoStr.replace("T", " ").replace(/\.\d+Z$/, "").replace(/\+\d{2}:\d{2}$/, "").substring(0, 19);
}

// è¾…åŠ©ï¼šåˆ¤æ–­æ˜¯å¦æ˜¯ä»Šå¤©
function isToday(isoStr) {
  if (!isoStr) return false;
  // ç®€å•çš„UTCè½¬æœ¬åœ°æ—¥æœŸæˆªå– (å…¼å®¹æ€§å¤„ç†)
  // ä¸ºç¡®ä¿å‡†ç¡®ï¼Œè¿™é‡Œç›´æŽ¥æ¯”è¾ƒâ€œå¹´æœˆæ—¥â€å­—ç¬¦ä¸²ï¼Œå¿½ç•¥æ—¶åŒºç»†å¾®å·®å¼‚ï¼Œå› ä¸ºç­¾åˆ°é€šå¸¸æŒ‰æœåŠ¡å™¨æ—¶é—´
  // å¦‚æžœéœ€è¦æžå…¶ä¸¥æ ¼çš„æ—¶åŒºå¤„ç†ï¼Œå¯ä½¿ç”¨ new Date().toLocaleDateString
  const logDate = isoStr.slice(0, 10);
  const nowDate = new Date().toISOString().slice(0, 10);
  return logDate === nowDate;
}

async function captureCookie() {
  const url = $request.url;
  // äºŒæ¬¡é˜²æŠ¤ï¼šæŽ’é™¤API
  if (url.includes("/user/checkin") || url.includes("/points-logs")) return;
  
  const h = $request.headers;
  const cookie = h['Cookie'] || h['cookie'];
  if (cookie && cookie.includes("token=")) {
    const old = $.getdata(KEY_COOKIE);
    if (cookie !== old) {
      $.setdata(cookie, KEY_COOKIE);
      const ua = h['User-Agent'] || h['user-agent'];
      const ref = h['Referer'] || h['referer'];
      if(ua) $.setdata(ua, KEY_UA);
      if(ref) $.setdata(ref, KEY_REFERER);
      $.msg($.name, "ðŸŽ‰ Cookie æ›´æ–°", "è¯·å…³é—­æ’ä»¶é…ç½®ä¸­çš„[è‡ªåŠ¨èŽ·å–]å¼€å…³");
    }
  }
}

function buildHeaders(cookie) {
  const ua = $.getdata(KEY_UA) || "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1";
  const referer = $.getdata(KEY_REFERER) || `https://${DOMAIN}/`;
  const token = (cookie.match(/token=([^;]+)/) || [])[1] || "";
  return { 'User-Agent': ua, 'Referer': referer, 'Origin': `https://${DOMAIN}`, 'Cookie': cookie, 'Authorization': `Bearer ${token}` };
}

// Env Polyfill
function Env(t,e){"undefined"!=typeof process&&JSON.stringify(process.env).indexOf("GITHUB")>-1&&process.exit(0);class s{constructor(t){this.env=t}write(t,e){switch(this.env){case"Surge":return $persistentStore.write(t,e);case"Quantumult X":return $prefs.setValueForKey(t,e);case"Loon":return $persistentStore.write(t,e)}}read(t){switch(this.env){case"Surge":return $persistentStore.read(t);case"Quantumult X":return $prefs.valueForKey(t);case"Loon":return $persistentStore.read(t)}}delete(t){switch(this.env){case"Surge":return $persistentStore.write(null,t);case"Quantumult X":return $prefs.removeValueForKey(t);case"Loon":return $persistentStore.write(null,t)}}post(t,e=null){const s=e?{url:t,...e}:t;if(e&&e.body&&!s.body&&(s.body=e.body),"Loon"===this.env||"Surge"===this.env)$httpClient.post(s,(t,e,s)=>{e.body=s,e.statusCode=e.status,this.done(e)});else if("Quantumult X"===this.env){const t=require("config");t.method="POST",t.url=s.url,t.headers=s.headers,t.body=s.body,$task.fetch(t).then(t=>{t.status=t.statusCode,this.done(t)},t=>{this.done(null)})}}get(t,e=null){const s=e?{url:t,...e}:t;if("Loon"===this.env||"Surge"===this.env)$httpClient.get(s,(t,e,s)=>{e.body=s,e.statusCode=e.status,this.done(e)});else if("Quantumult X"===this.env){const t=require("config");t.method="GET",t.url=s.url,t.headers=s.headers,$task.fetch(t).then(t=>{t.status=t.statusCode,this.done(t)},t=>{this.done(null)})}}}return new class{constructor(t,s){this.name=t,this.http=new class{post(t){return new Promise((e,s)=>{new Env("Loon").post(t,(t,r,n)=>{t?s(t):e(r)})})}get(t){return new Promise((e,s)=>{new Env("Loon").get(t,(t,r,n)=>{t?s(t):e(r)})})}},this.data=null,this.dataFile="box.dat",this.logs=[],this.isSurge="undefined"!=typeof $httpClient&&"undefined"==typeof $loon,this.isQuantumultX="undefined"!=typeof $task,this.isLoon="undefined"!=typeof $loon,this.isNode="undefined"!=typeof module&&!!module.exports,this.logSeparator="\n"}getdata(t){if(this.isLoon||this.isSurge)return new Env("Loon").read(t);if(this.isQuantumultX)return new Env("Quantumult X").read(t)}setdata(t,e){if(this.isLoon||this.isSurge)return new Env("Loon").write(t,e);if(this.isQuantumultX)return new Env("Quantumult X").write(t,e)}msg(t,e,s){this.isLoon&&$notification.post(t,e,s),this.isSurge&&$notification.post(t,e,s),this.isQuantumultX&&$notify(t,e,s),this.logs.push(t,e,s)}log(t){console.log(t),this.logs.push(t)}logErr(t){console.log(t),this.logs.push(t)}done(t={}){const e=(new Date).getTime();this.isLoon||this.isSurge?$done(t):this.isQuantumultX&&$done(t)}}(t,e)}
