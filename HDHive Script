const $ = new Env("HDHive");

// ========= å¸¸é‡ =========
const DOMAIN = "hdhive.com";

const KEY_COOKIE = "hdhive_cookie_v14";
const KEY_REFERER = "hdhive_referer_v14";
const KEY_UA = "hdhive_ua_v14";
const KEY_CSRF = "hdhive_csrf_v14";
const KEY_FLOW = "hdhive_points_flow_v3";

// ========= å…¥å£ =========
(async () => {
  if (typeof $request !== "undefined") {
    await captureCookie();
  } else {
    await checkIn();
  }
})().catch(e => $.logErr(e)).finally(() => $.done());

// ========= æŠ“ Cookieï¼ˆå¢å¼ºï¼šåˆå¹¶å¤šè¡Œ cookie + ä¿å­˜ csrf_access_tokenï¼‰ =========
async function captureCookie() {
  const url = $request.url || "";
  if (!url.includes(DOMAIN)) return;

  // é¿å…ç­¾åˆ°è¯·æ±‚è¦†ç›–ï¼ˆå¯æŒ‰éœ€åˆ ï¼‰
  if (/\/(go-api|api)\/customer\/(user\/)?checkin/i.test(url)) return;

  const h = $request.headers || {};
  const cookie = getCookieFromHeaders(h);
  const ua = getHeader(h, "User-Agent");
  const referer = getHeader(h, "Referer");

  if (!cookie || cookie.length < 20) return;

  const ckObj = parseCookie(cookie);
  if (!ckObj.token) return;

  const old = $.getdata(KEY_COOKIE);
  if (cookie !== old) {
    $.setdata(cookie, KEY_COOKIE);
    if (ua) $.setdata(ua, KEY_UA);
    if (referer) $.setdata(referer, KEY_REFERER);

    if (ckObj.csrf_access_token) $.setdata(ckObj.csrf_access_token, KEY_CSRF);

    $.msg("HDHive", "ğŸ‰ Cookie å·²æ›´æ–°", "å·²ä¿å­˜ token + csrf_access_tokenï¼ˆå¦‚æœ‰ï¼‰");
  }
}

// ========= æ ¸å¿ƒï¼šæŒ‰æŠ“åŒ…æ‹‰ç§¯åˆ†æ—¥å¿—ï¼ˆNext.js RSC â†’ è§£æ initialDataï¼‰ =========
async function activeFetchPointsFlow(headers) {
  // ä½ çš„æŠ“åŒ…å°±æ˜¯è¿™ä¸ªï¼š/manager/points-logs?page=2&page_size=10&_rsc=xxxx
  // è¿™é‡Œ page=1 è·å–æœ€æ–° 10 æ¡
  const url = `https://${DOMAIN}/manager/points-logs?page=1&page_size=10&_rsc=1`;

  try {
    const raw = await httpGetText(url, headers);
    if (!raw || raw.length < 200) return null;

    const list = extractInitialDataArray(raw);
    if (!Array.isArray(list) || !list.length) return null;

    const latest = list[0];
    const recent = list.slice(0, 3).map(x =>
      `- ${formatTime(x.created_at)}ï¼š${x.points > 0 ? "+" : ""}${x.points}ï¼ˆ${x.remark || x.change_type || ""}ï¼‰`
    );

    const flow = {
      user_id: latest.user_id,
      latest_checkin: {
        time: latest.created_at,
        points: latest.points,
        remark: latest.remark || latest.change_type
      },
      recent_checkins: recent
    };

    $.setdata(JSON.stringify(flow), KEY_FLOW);
    return flow;
  } catch {
    return null;
  }
}

// ========= æ„å»ºå±•ç¤ºæ–‡æœ¬ =========
function buildFlowText(flow) {
  if (!flow) return "";
  const l = [];
  if (flow.user_id) l.push(`ç”¨æˆ·IDï¼š${flow.user_id}`);
  if (flow.latest_checkin?.time) l.push(`æœ€æ–°å˜åŠ¨ï¼š${formatTime(flow.latest_checkin.time)}`);
  if (flow.latest_checkin?.points !== undefined)
    l.push(`å˜åŠ¨æ•°å€¼ï¼š${flow.latest_checkin.points > 0 ? "+" : ""}${flow.latest_checkin.points} ç§¯åˆ†`);
  if (flow.latest_checkin?.remark) l.push(`å†…å®¹æè¿°ï¼š${flow.latest_checkin.remark}`);
  if (flow.recent_checkins?.length) {
    l.push("");
    l.push("ğŸ“ ç§¯åˆ†æ—¥å¿—ï¼š");
    l.push(flow.recent_checkins.join("\n"));
  }
  return l.join("\n");
}

// ========= ç­¾åˆ°ï¼ˆä¸¥æ ¼åˆ¤å®šï¼Œä¸å†è¯¯æŠ¥æˆåŠŸï¼‰ =========
async function checkIn() {
  const rawCookie = $.getdata(KEY_COOKIE);
  if (!rawCookie) {
    $.msg("HDHive", "âŒ æ— æ³•ç­¾åˆ°", "æœªè·å– Cookie");
    return;
  }

  const ckObj = parseCookie(rawCookie);
  const token = ckObj.token;
  if (!token) {
    $.msg("HDHive", "âŒ Cookie å¤±æ•ˆ", "ç¼ºå°‘ token");
    return;
  }

  const ua =
    $.getdata(KEY_UA) ||
    "Mozilla/5.0 (iPhone; CPU iPhone OS 18_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.2 Mobile/15E148 Safari/604.1";

  // æŠ“åŒ… referer å¤šä¸º manager é¡µ
  const referer = $.getdata(KEY_REFERER) || `https://${DOMAIN}/manager/points-logs`;
  const csrf = $.getdata(KEY_CSRF) || ckObj.csrf_access_token || "";

  // ---- åŸºç¡€å¤´ï¼ˆåŒæ—¶å…¼å®¹ç­¾åˆ°ä¸ points-logs RSCï¼‰ ----
  const headers = {
    "User-Agent": ua,
    "Accept": "application/json, text/plain, */*",
    "Content-Type": "application/json;charset=utf-8",
    "Origin": `https://${DOMAIN}`,
    "Referer": referer,
    "Accept-Language": "zh-CN,zh-Hans;q=0.9",
    "Cookie": normalizeCookie(rawCookie),

    // RSC å…³é”®å¤´ï¼ˆæŒ‰æŠ“åŒ…ï¼‰
    "rsc": "1",
    "next-url": "/manager/points-logs",
  };

  // å¦‚æœæœåŠ¡ç«¯ç”¨ Bearerï¼Œå°±å¸¦ä¸Šï¼›å¦‚æœä¸ç”¨ï¼Œä¹Ÿä¸å½±å“ points-logsï¼ˆå®ƒé  cookieï¼‰
  headers["Authorization"] = `Bearer ${token}`;

  // CSRFï¼ˆå®‰å…¨èµ·è§åŒå†™å¤§å°å†™ï¼‰
  if (csrf) {
    headers["X-CSRF-Token"] = csrf;
    headers["X-Csrf-Token"] = csrf;
  }

  // ---- ç­¾åˆ°æ¥å£å¤šè·¯å¾„å°è¯• ----
  const endpoints = [
    `https://${DOMAIN}/api/customer/user/checkin`,
    `https://${DOMAIN}/go-api/customer/user/checkin`,
    `https://${DOMAIN}/api/customer/checkin`,
    `https://${DOMAIN}/go-api/customer/checkin`,
  ];

  let checkinRes = null;
  let status = 0;
  let raw = "";

  for (const url of endpoints) {
    const req = { url, method: "POST", headers, body: "{}" };
    const r = await httpPostRaw(req);
    if (!r) continue;

    status = r.status;
    raw = r.data || "";

    // å¿…é¡»æ˜¯ JSON æ‰ç»§ç»­åˆ¤æ–­
    let json = null;
    try { json = JSON.parse(raw); } catch {}

    // ä¸æ˜¯ JSONï¼šç»§ç»­æ¢ endpoint
    if (!json) continue;

    checkinRes = json;
    break;
  }

  // å®Œå…¨æ²¡æ‹¿åˆ° JSONï¼šæ˜ç¡®å‘Šè¯‰ä½ å¤±è´¥ï¼ˆä¸ä¼šå†è¯¯æŠ¥æˆåŠŸï¼‰
  if (!checkinRes) {
    $.msg(
      "HDHive",
      "âŒ ç­¾åˆ°å¤±è´¥",
      `æœªè·å–åˆ°æœ‰æ•ˆ JSON å“åº”ï¼ˆå¯èƒ½æ¥å£ä¸å¯¹/è¢«é‡å®šå‘/é‰´æƒå¤±è´¥ï¼‰\nHTTP ${status}\nè¿”å›ç‰‡æ®µï¼š${String(raw).slice(0, 200)}`
    );
    return;
  }

  const msg = checkinRes.message || checkinRes.msg || "";
  const code = checkinRes.code;

  // æ›´ä¸¥æ ¼çš„æˆåŠŸåˆ¤æ–­
  const ok =
    (status === 200 || status === 201) &&
    (
      code === 0 || code === 200 || code === "0" ||
      /æˆåŠŸ|å·²ç­¾åˆ°|å·²ç»|æ˜å¤©/.test(msg) ||
      checkinRes.data
    );

  if (!ok) {
    $.msg("HDHive", "âŒ ç­¾åˆ°å¤±è´¥", `HTTP ${status}\ncode=${code}\nmsg=${msg || "(ç©º)"}\nraw=${JSON.stringify(checkinRes).slice(0, 300)}`);
    return;
  }

  const checked =
    /å·²ç»|æ˜å¤©/.test(msg) ||
    msg.toLowerCase().includes("already") ||
    msg.toLowerCase().includes("checked");

  // ---- æ‹‰ç§¯åˆ†æ—¥å¿—ï¼ˆæŒ‰æŠ“åŒ…ï¼‰ ----
  let flow = await activeFetchPointsFlow(headers);
  if (!flow) {
    try { flow = JSON.parse($.getdata(KEY_FLOW) || "null"); } catch {}
  }

  const flowText = flow ? "\n\n" + buildFlowText(flow) : "\n\nï¼ˆæœªæ‹‰åˆ°ç§¯åˆ†æ—¥å¿—ï¼šè¯·ç¡®è®¤å·² MITM è§£å¯† hdhive.comï¼Œä¸” cookie ä»æœ‰æ•ˆï¼‰";

  $.msg(
    "HDHive",
    checked ? "ğŸŸ¢ ä»Šæ—¥å·²ç­¾åˆ°" : "âœ… ç­¾åˆ°æˆåŠŸ",
    `${msg || "ç­¾åˆ°è¯·æ±‚æˆåŠŸ"}${flowText}`
  );
}

// ========= HTTP å·¥å…· =========
function httpGetText(url, headers) {
  return new Promise((resolve, reject) => {
    $.get({ url, headers }, (err, resp, data) => {
      if (err) return reject(err);
      resolve(typeof data === "string" ? data : "");
    });
  });
}

function httpPostRaw(req) {
  return new Promise((resolve) => {
    $.post(req, (err, resp, data) => {
      if (err) return resolve(null);
      const status = resp?.status || resp?.statusCode || 0;
      resolve({ status, data: (typeof data === "string" ? data : "") });
    });
  });
}

// ========= è§£æ RSCï¼šæå– initialData æ•°ç»„ =========
function extractInitialDataArray(raw) {
  const key = '"initialData":';
  const idx = raw.indexOf(key);
  if (idx < 0) return null;

  let i = raw.indexOf("[", idx + key.length);
  if (i < 0) return null;

  // bracket matchingï¼šèƒ½æŠ— RSC é‡Œå„ç§åµŒå¥—
  let depth = 0;
  let inStr = false;
  let esc = false;

  for (let j = i; j < raw.length; j++) {
    const ch = raw[j];

    if (inStr) {
      if (esc) { esc = false; continue; }
      if (ch === "\\") { esc = true; continue; }
      if (ch === '"') inStr = false;
      continue;
    } else {
      if (ch === '"') { inStr = true; continue; }
      if (ch === "[") depth++;
      if (ch === "]") {
        depth--;
        if (depth === 0) {
          const jsonText = raw.slice(i, j + 1);
          try { return JSON.parse(jsonText); } catch { return null; }
        }
      }
    }
  }
  return null;
}

// ========= Cookie/Headers å·¥å…· =========
function getCookieFromHeaders(h) {
  let v = null;
  for (const k in h) {
    if (k.toLowerCase() === "cookie") { v = h[k]; break; }
  }
  if (!v) return null;
  if (Array.isArray(v)) return normalizeCookie(v.join("; "));
  return normalizeCookie(String(v));
}

function normalizeCookie(str) {
  return String(str)
    .replace(/\r?\n/g, "; ")
    .replace(/;+\s*/g, "; ")
    .replace(/\s*;\s*$/, "")
    .trim();
}

function parseCookie(str) {
  const obj = {};
  normalizeCookie(str).split(";").forEach(p => {
    const i = p.indexOf("=");
    if (i > 0) obj[p.slice(0, i).trim()] = p.slice(i + 1).trim();
  });
  return obj;
}

function getHeader(h, k) {
  const key = k.toLowerCase();
  for (const i in h) {
    if (i.toLowerCase() === key) return h[i];
  }
  return null;
}

function formatTime(t) {
  return (t || "")
    .replace("T", " ")
    .replace(/\..*$/, "")
    .replace(/\+\d\d:\d\d$/, "");
}

// ========= Env =========
function Env(name) {
  return {
    name,
    getdata: k => $persistentStore?.read(k),
    setdata: (v, k) => $persistentStore?.write(v, k),
    post: (o, c) => $httpClient?.post(o, c),
    get: (o, c) => $httpClient?.get(o, c),
    msg: (t, s, b) => {
      $notification?.post(t, s, b);
      console.log(`===${t}===\n${s}\n${b}`);
    },
    logErr: e => console.log(`â—ï¸${name}: ${e}`),
    done: () => $done?.({})
  };
}