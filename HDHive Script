/*
HDHive è‡ªåŠ¨ç­¾åˆ° (æµæ°´å…¨è®°å½• & æ—¥å¿—ç²¾ç®€ç‰ˆ)
Update: 2026-01-29
*/

const $ = new Env("HDHive");
const KEY_COOKIE = 'hdhive_cookie_v12';
const KEY_REFERER = 'hdhive_referer_v12';
const KEY_UA = 'hdhive_ua_v12';
const KEY_FLOW = 'hdhive_points_flow_v1';
const DOMAIN = 'hdhive.com';

(async () => {
  if (typeof $request !== "undefined") {
    await captureCookie();
  } else {
    await checkIn();
  }
})().catch(e => $.logErr(e)).finally(() => $.done());

async function captureCookie() {
  const url = $request.url || "";
  if (!url.includes(DOMAIN) || url.includes("user/checkin")) return;
  const h = $request.headers || {};
  const cookie = getHeader(h, 'Cookie');
  if (!cookie || !cookie.includes("token=")) return;
  if (cookie !== $.getdata(KEY_COOKIE)) {
    $.setdata(cookie, KEY_COOKIE);
    $.setdata(getHeader(h, 'User-Agent'), KEY_UA);
    $.setdata(getHeader(h, 'Referer'), KEY_REFERER);
    $.msg("HDHive", "ðŸŽ‰ Cookie å·²èŽ·å–", "");
  }
}

async function activeFetchPointsFlow(headers) {
  const url = `https://${DOMAIN}/go-api/customer/points-logs?page=1&page_size=10`;
  try {
    const json = await httpGetJson(url, headers);
    const list = json?.data?.list;
    if (!Array.isArray(list) || !list.length) return null;

    const latest = list[0];
    const flow = {
      user_id: latest.user_id || "æœªçŸ¥",
      latest_item: {
        time: latest.created_at,
        points: latest.points,
        remark: latest.remark || latest.change_type
      },
      recent_items: list.slice(0, 3).map(x => 
        `- ${formatTime(x.created_at)}ï¼š+${x.points}ï¼ˆ${x.remark || x.change_type}ï¼‰`
      )
    };
    $.setdata(JSON.stringify(flow), KEY_FLOW);
    console.log(`âœ… æµæ°´æ‹‰å–æˆåŠŸ: æœ€æ–°å˜åŠ¨ä¸º [${latest.change_type}]`);
    return flow;
  } catch (e) {
    console.log(`âŒ æµæ°´èŽ·å–å¤±è´¥: ${e}`);
    return null;
  }
}

function buildFlowText(flow) {
  if (!flow) return "";
  return [
    `ç”¨æˆ·IDï¼š${flow.user_id}`,
    `æœ€æ–°è®°å½•ï¼š${formatTime(flow.latest_item.time)}`,
    `å˜åŠ¨æ•°å€¼ï¼š+${flow.latest_item.points} ç§¯åˆ†`,
    `å†…å®¹æè¿°ï¼š${flow.latest_item.remark}`,
    "\nðŸ“ è¿‘æœŸæµæ°´è®°å½•ï¼š",
    ...flow.recent_items
  ].filter(Boolean).join("\n");
}

async function checkIn() {
  const rawCookie = $.getdata(KEY_COOKIE);
  if (!rawCookie) return $.msg("HDHive", "âŒ æ— æ³•ç­¾åˆ°", "æœªèŽ·å– Cookie");
  
  const token = parseCookie(rawCookie)['token'];
  const headers = {
    'User-Agent': $.getdata(KEY_UA) || 'Mozilla/5.0',
    'Authorization': token ? `Bearer ${token}` : '',
    'Cookie': rawCookie,
    'Referer': $.getdata(KEY_REFERER) || `https://${DOMAIN}/`,
    'Content-Type': 'application/json'
  };

  const req = { url: `https://${DOMAIN}/api/customer/user/checkin`, method: "POST", headers, body: "{}" };
  console.log("ðŸš€ å‘èµ·ç­¾åˆ°è¯·æ±‚...");

  return new Promise(resolve => {
    $.post(req, async (err, resp, data) => {
      let msg = "è¯·æ±‚è¶…æ—¶", isSuccess = false;
      if (!err && data) {
        const res = JSON.parse(data);
        msg = res.message || "æœªçŸ¥å“åº”";
        isSuccess = msg.includes("æˆåŠŸ") || msg.includes("å·²ç»") || msg.includes("æ˜Žå¤©");
        console.log(`ðŸ“¦ ç­¾åˆ°ç»“æžœ: ${msg}`);
      }
      
      let flow = await activeFetchPointsFlow(headers) || JSON.parse($.getdata(KEY_FLOW) || "null");
      $.msg("HDHive", isSuccess ? "ðŸŸ¢ ç­¾åˆ°æ‰§è¡Œå®Œæ¯•" : "âŒ ç­¾åˆ°å¼‚å¸¸", `${msg}\n\n${buildFlowText(flow)}`);
      resolve();
    });
  });
}

// ========= å·¥å…·å‡½æ•° =========
function httpGetJson(url, headers) {
  return new Promise((resolve, reject) => {
    $.get({ url, headers }, (err, resp, data) => {
      if (err) return reject(err);
      try { resolve(JSON.parse(data)); } catch (e) { reject(e); }
    });
  });
}

function parseCookie(str) {
  const obj = {};
  if (!str) return obj;
  str.split(';').forEach(p => {
    const i = p.indexOf('=');
    if (i > 0) obj[p.slice(0, i).trim()] = p.slice(i + 1).trim();
  });
  return obj;
}

function getHeader(h, k) {
  const key = k.toLowerCase();
  for (const i in h) if (i.toLowerCase() === key) return h[i];
  return null;
}

function formatTime(t) {
  if (!t) return "æœªçŸ¥æ—¶é—´";
  return t.replace("T", " ").replace(/\..*$/, "").replace(/\+\d\d:\d\d$/, "");
}

function Env(name) {
  return {
    name,
    getdata: k => $persistentStore.read(k),
    setdata: (v, k) => $persistentStore.write(v, k),
    post: (o, c) => $httpClient.post(o, c),
    get: (o, c) => $httpClient.get(o, c),
    msg: (t, s, b) => $notification.post(t, s, b),
    logErr: e => console.log(`! ${name} é”™è¯¯: ${e}`),
    done: () => $done({})
  };
}
