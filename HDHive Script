/*
HDHive è‡ªåŠ¨ç­¾åˆ°
Update: 2026-01-16
åŠŸèƒ½ï¼šå…¨è®°å½•æµæ°´èŽ·å– + è¯¦ç»†è°ƒè¯•æ—¥å¿—
*/

const $ = new Env("HDHive");
const KEY_COOKIE = 'hdhive_cookie_v12';
const KEY_REFERER = 'hdhive_referer_v12';
const KEY_UA = 'hdhive_ua_v12';
const KEY_FLOW = 'hdhive_points_flow_v1';
const DOMAIN = 'hdhive.com';

(async () => {
  if (typeof $request !== "undefined") {
    await captureCookie();
  } else {
    await checkIn();
  }
})().catch(e => $.logErr(e)).finally(() => $.done());

// ========= æŠ“å–æ¨¡å— =========
async function captureCookie() {
  const url = $request.url || "";
  if (!url.includes(DOMAIN) || url.includes("user/checkin")) return;
  const h = $request.headers || {};
  const cookie = getHeader(h, 'Cookie');
  if (!cookie || !cookie.includes("token=")) return;
  const old = $.getdata(KEY_COOKIE);
  if (cookie !== old) {
    $.setdata(cookie, KEY_COOKIE);
    const ua = getHeader(h, 'User-Agent');
    const referer = getHeader(h, 'Referer');
    if (ua) $.setdata(ua, KEY_UA);
    if (referer) $.setdata(referer, KEY_REFERER);
    $.msg("HDHive", "ðŸŽ‰ Cookie å·²æ›´æ–°", "å¯ä»¥é‡æ–°è¿è¡Œç­¾åˆ°è„šæœ¬");
  }
}

// ========= æµæ°´èŽ·å–æ¨¡å— (åŒ…å«è¯¦ç»†æ—¥å¿—) =========
async function activeFetchPointsFlow(headers) {
  const url = `https://${DOMAIN}/go-api/customer/points-logs?page=1&page_size=10`;
  console.log(`ðŸ” æ­£åœ¨è¯·æ±‚ç§¯åˆ†æµæ°´: ${url}`);
  try {
    const json = await httpGetJson(url, headers);
    // è°ƒè¯•æ—¥å¿—ï¼šæ‰“å°å®Œæ•´è¿”å›žå†…å®¹ï¼Œæ–¹ä¾¿æŽ’æŸ¥æ•°æ®ç»“æž„
    console.log("ðŸ“¦ æŽ¥å£è¿”å›žè¯¦æƒ…: " + JSON.stringify(json));

    const list = json?.data?.list;
    if (!Array.isArray(list) || !list.length) {
      console.log("âš ï¸ è­¦å‘Šï¼šç§¯åˆ†æµæ°´åˆ—è¡¨ä¸ºç©ºæˆ–è§£æžå¤±è´¥");
      return null;
    }

    const latest = list[0];
    console.log(`âœ… æˆåŠŸèŽ·å– ${list.length} æ¡æµæ°´ï¼Œæœ€æ–°ä¸€æ¡ï¼š${latest.change_type} (+${latest.points})`);

    const flow = {
      user_id: latest.user_id || "æœªçŸ¥",
      latest_item: {
        time: latest.created_at,
        points: latest.points,
        remark: latest.remark || latest.change_type || "å˜åŠ¨"
      },
      recent_items: list.slice(0, 3).map(x => 
        `- ${formatTime(x.created_at)}ï¼š+${x.points}ï¼ˆ${x.remark || x.change_type}ï¼‰`
      )
    };
    $.setdata(JSON.stringify(flow), KEY_FLOW);
    return flow;
  } catch (e) {
    console.log("âŒ èŽ·å–æµæ°´è¯·æ±‚å¼‚å¸¸: " + e);
    return null;
  }
}

// ========= æž„å»ºé€šçŸ¥æ–‡æœ¬ =========
function buildFlowText(flow) {
  if (!flow) return "";
  return [
    `ç”¨æˆ·IDï¼š${flow.user_id}`,
    `æœ€æ–°å˜åŠ¨ï¼š${formatTime(flow.latest_item.time)}`,
    `å˜åŠ¨æ•°å€¼ï¼š+${flow.latest_item.points} ç§¯åˆ†`,
    flow.latest_item.remark ? `è¯´æ˜Žï¼š${flow.latest_item.remark}` : "",
    "\nðŸ“ è¿‘æœŸæµæ°´è®°å½•ï¼š",
    ...flow.recent_items
  ].filter(Boolean).join("\n");
}

// ========= ç­¾åˆ°æ¨¡å— =========
async function checkIn() {
  const rawCookie = $.getdata(KEY_COOKIE);
  if (!rawCookie) return $.msg("HDHive", "âŒ æ— æ³•ç­¾åˆ°", "æœªèŽ·å– Cookie");
  
  const token = parseCookie(rawCookie)['token'];
  const headers = {
    'User-Agent': $.getdata(KEY_UA) || 'Mozilla/5.0',
    'Accept': 'application/json, text/plain, */*',
    'Content-Type': 'application/json;charset=utf-8',
    'Origin': `https://${DOMAIN}`,
    'Referer': $.getdata(KEY_REFERER) || `https://${DOMAIN}/`,
    'Authorization': token ? `Bearer ${token}` : '',
    'Cookie': rawCookie
  };

  const req = { url: `https://${DOMAIN}/api/customer/user/checkin`, method: "POST", headers, body: "{}" };
  console.log("ðŸš€ æ­£åœ¨å‘èµ·ç­¾åˆ°è¯·æ±‚...");

  return new Promise(resolve => {
    $.post(req, async (err, resp, data) => {
      let msg = "è¯·æ±‚å¤±è´¥", isSuccess = false;
      
      if (!err && data) {
        console.log("ðŸ“¦ ç­¾åˆ°æŽ¥å£å“åº”: " + data);
        try {
          const res = JSON.parse(data);
          msg = res.message || "æœªçŸ¥å“åº”";
          isSuccess = msg.includes("æˆåŠŸ") || msg.includes("å·²ç»") || msg.includes("æ˜Žå¤©");
        } catch (e) {
          console.log("âŒ ç­¾åˆ°å“åº”è§£æžå¼‚å¸¸: " + e);
        }
      } else if (err) {
        console.log("âŒ ç­¾åˆ°è¯·æ±‚é”™è¯¯: " + err);
      }

      // æ— è®ºç­¾åˆ°ç»“æžœå¦‚ä½•ï¼Œéƒ½å°è¯•æ‹‰å–æœ€æ–°æµæ°´
      let flow = await activeFetchPointsFlow(headers);
      if (!flow) {
        console.log("â„¹ï¸ å°è¯•è¯»å–æœ¬åœ°ç¼“å­˜æµæ°´æ•°æ®...");
        try { flow = JSON.parse($.getdata(KEY_FLOW) || "null"); } catch {}
      }

      const flowText = flow ? "\n\n" + buildFlowText(flow) : "\n\n(æµæ°´èŽ·å–å¤±è´¥)";
      $.msg("HDHive", isSuccess ? "ðŸŸ¢ ç­¾åˆ°æ‰§è¡Œå®Œæ¯•" : "âŒ ç­¾åˆ°å¼‚å¸¸", `${msg}${flowText}`);
      resolve();
    });
  });
}

// ========= å·¥å…·å‡½æ•° =========
function httpGetJson(url, headers) {
  return new Promise((resolve, reject) => {
    $.get({ url, headers }, (err, resp, data) => {
      if (err) return reject(err);
      try { resolve(JSON.parse(data)); } catch (e) { reject(e); }
    });
  });
}

function parseCookie(str) {
  const obj = {};
  if (!str) return obj;
  str.split(';').forEach(p => {
    const i = p.indexOf('=');
    if (i > 0) obj[p.slice(0, i).trim()] = p.slice(i + 1).trim();
  });
  return obj;
}

function getHeader(h, k) {
  const key = k.toLowerCase();
  for (const i in h) if (i.toLowerCase() === key) return h[i];
  return null;
}

function formatTime(t) {
  if (!t) return "æœªçŸ¥æ—¶é—´";
  return t.replace("T", " ").replace(/\..*$/, "").replace(/\+\d\d:\d\d$/, "");
}

function Env(name) {
  return {
    name,
    getdata: k => $persistentStore.read(k),
    setdata: (v, k) => $persistentStore.write(v, k),
    post: (o, c) => $httpClient.post(o, c),
    get: (o, c) => $httpClient.get(o, c),
    msg: (t, s, b) => {
      $notification.post(t, s, b);
      console.log(`===${t}===\n${s}\n${b}`);
    },
    logErr: e => console.log(`! ${name} é”™è¯¯: ${e}`),
    done: () => $done({})
  };
}
